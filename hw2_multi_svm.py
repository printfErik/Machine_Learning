# -*- coding: utf-8 -*-
"""hw2_multi_svm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fk45ltrnUMNqAxW3HXu7dSekU_x-JUco
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from numpy import linalg as LA
import cvxopt
cvxopt.solvers.options['show_progress'] = False

# from problem 5, RBF-SVM
def rbf_svm_train(X, y, c, sigma):
  size = np.shape(X)[0]
  R = cvxopt.matrix(np.matmul(X.T,np.diag(y))) #used for compute weights
  # define P,q,G,h for corresponding parameter in qp solver
  P = np.zeros((size,size))
  for i in range(size):
    for j in range(size):
      P[i,j] = y[i]*y[j] * np.exp(-1*(np.linalg.norm(X[i]-X[j]))**2/(2*sigma**2))
  P = cvxopt.matrix(P)
  q = -cvxopt.matrix(np.ones(size)) # -1
  G = cvxopt.matrix(np.concatenate((np.eye(size),-np.eye(size)))) # constrains
  h = cvxopt.matrix(np.concatenate((np.ones(size)*c,np.zeros(size)))) # constrains
  ans = cvxopt.solvers.qp(P,q,G,h) 
  alpha = ans['x']
  #print(alpha)
  weight = np.matmul(R,alpha)
  return alpha, weight

# from problem 5, RBF-SVM
# using computed weight to predict
def rbf_svm_predict(test_X,train_X,train_y,alpha,sigma):
  size = np.shape(test_X)[0]
  ans = np.zeros(size)
  for i in range(size):
    for j in range(np.shape(train_X)[0]):
      ans[i] = ans[i] + np.exp(-1* (np.linalg.norm(test_X[i] - train_X[j]))**2/(2*sigma**2))*alpha[j]*train_y[j]
  return ans

# return alpha is a multi-dimensional array
def mnist_svm_train(X, y, c,sigma):
  X = X.astype(float)
  y = y.astype(float)
  size = np.shape(X)[0]
  alpha = np.zeros((10,size,1))
  weights = np.zeros((10,64,1))
  # compute single alpha for each label from 1 to 10
  for j in range(10): 
    y_temp = np.array(y)
    for n in range(len(y_temp)):
      if y_temp[n] != j+1:
        y_temp[n] = -1.0
      else:
        y_temp[n] = 1.0
    a, weight = rbf_svm_train(X,y_temp,c,sigma)
    alpha[j] = a
    weights[j] = weight
  return alpha, weights

def mnist_svm_predict(test_X,train_X,train_y,alpha,sigma):
  lmax = np.zeros(len(test_X))
  label = np.ones(len(test_X))
  for i in range(10):
    y_temp = np.array(train_y)
    for n in range(len(y_temp)):
      if y_temp[n] != i+1:
        y_temp[n] = -1.0
      else:
        y_temp[n] = 1.0
    alpha1, weight = rbf_svm_train(train_X, y_temp, 1, sigma)
    ans = rbf_svm_predict(test_X,train_X,y_temp,alpha1,sigma)
    #print(ans)
    if (i == 0):
      lmax = np.array(ans)
    else:
      for j in range(len(test_X)):
        if lmax[j] < ans[j]:
          lmax[j] = ans[j]
          label[j] = i+1
  return label


# cleaning data from string to float or int
test_data = pd.read_csv("mfeat_test.csv",header = None).values

train_data = pd.read_csv("mfeat_train.csv",header = None).values

X_train = train_data[1:,1:-1]
y_train = train_data[1:,-1]
X_test = test_data[1:,1:-1]
y_test = test_data[1:,-1]

for i in range(len(X_train)):
   X_train[i] = X_train[i].astype(float)

for j in range(len(X_test)):
   X_test[j] = X_test[j].astype(float)

y_train = y_train.astype(int)
y_test = y_test.astype(int)

# compute alpha for predict function
alpha, weights = mnist_svm_train(X_train,y_train,1,1)

# reshape from 3d to 2d
new_weight = np.zeros((10,64))
for i in range(10):
  for j in range(64):
    new_weight[i][j] = weights[i][j][0]
np.shape(new_weight)


# save weights file
np.savetxt("multi_svm_weights.txt",new_weight)
from google.colab import files

with open('example.txt', 'w') as f:
  f.write('some content')

files.download('multi_svm_weights.txt')


# compute all labels for test data
label = mnist_svm_predict(X_test,X_train,y_train,alpha,1)

# compute accuracy
correct = 0 

# compute confusionMatrix
confusionMatrix = np.zeros((10,10),dtype=int)
for i in range(len(y_test)):   
  i_label = int(label[i])   
  #print(label[i])
  #print(y_test[i])
  if (y_test[i] == i_label):
    correct += 1 
  confusionMatrix[i_label-1, y_test[i]-1]+=1
print(confusionMatrix)
print("accuracy: ", correct / len(X_test))

